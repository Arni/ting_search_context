<?php

/**
 * @file
 *
 * Module file for the Ting search context module.
 */

// Constants
define('TING_SEARCH_CONTEXT_PATH', drupal_get_path('module', 'ting_search_context'));
define('TING_SEARCH_CONTEXT_MAX_RATING', 10);

include_once 'ting_search_context.features.inc';

/**
 * Implements hook_menu().
 */
function ting_search_context_menu() {
	/*$items['admin/content/ting-search-context'] = array(
		'title' => 'Search context',
		'description' => t('Manage the state of the context rating system.'),
		'page callback' => 'drupal_get_form',
		'page arguments' => array('ting_search_context_overview_form'),
		'access arguments' => array('administer content'), // Todo: Make own permission?
		'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
		'file' => 'ting_search_context.admin.inc',
	);*/
  $items['ting/searchcontext/ajax'] = array(
    'title' => 'Get search context blog post list',
    'page callback' => 'ting_search_context_ajax_get_blogposts',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function ting_search_context_theme($existing, $type, $theme, $path) {
  return array(
    'ting_search_context' => array(
      'variables' => array('columns' => NULL),
      'template'  => 'ting-search-context',
      'path' => $path . '/templates',
    ),
    'views_view_field__ting_search_context_rate_nodes__title' => array(
      'variables' => array('view' => NULL, 'options' => NULL, 'row' => NULL),
      'template' => 'views-view-field--ting-search-context-rate-nodes--title',
      'base hook' => 'views_views_field',
      'path' => $path . '/templates',
      'preprocess functions' => array(
        'template_preprocess',
        'template_preprocess_views_view_field',
      ),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 *
 * It simply tells panels where to find the .inc files that define various
 * args, contexts, content_types.
 */
function ting_search_context_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin)) {
    return "plugins/$plugin";
  }
}

function ting_search_context_ajax_get_blogposts() {
  $search_context = $_POST['search_context'];
  $nodes = ting_search_context_get_nodes($search_context);
  $outpu = '';
  if (!empty($nodes)) {
    $output = ting_search_context_theme_output ($nodes);
  }
  return drupal_json_output($output);
}

function ting_search_context_theme_output($nodes) {
  $columns = array();
  $columns_classes = array(
    ' group-blocks--first',
    ' group-blocks--second',
    ' group-blocks--third',
    ' group-blocks--fourth',
  );
  foreach ($columns_classes as $columns_class) {
    if (!empty($nodes)) {
      $node = array_shift($nodes);
      $field_name = ting_search_context_get_image_field_name($node);
      $image = field_view_field('node', $node, $field_name, array(
        'label' => 'hidden',
        'settings' => array(
          'image_style' => 'ting_related_links_medium', // We take care of the linking ourself
        ),
      ));
      $url = url(drupal_get_path_alias('node/' . $node->nid), array('absolute' => TRUE));
      $url .= '?WT.cg_n=searchcontext';
      $columns[$columns_class] = array(
        'title' => $node->title,
        'image' => drupal_render($image),
        'url' => $url,
      );
    }
  }
  return theme('ting_search_context', array('columns' => $columns));
}

function ting_search_context_get_image_field_name($node) {
  $type = $node->type;
  if ($type == 'ding_news') {
    return 'field_ding_news_list_image';
  } else if ($type == 'ding_event') {
    return 'field_ding_event_list_image';
  } else if ($type == 'ding_eresource') {
    return 'field_ding_eresource_list_image';
  } else if ($type == 'genre_page') {
    return 'field_genre_page_list_image';
  } else if ($type == 'ding_page') {
    return 'field_ding_page_list_image';
  }
  return '';
}

/**
 * Implements hook_action_info().
 */
function ting_search_context_action_info() {
  return array(
    'ting_search_context_rate_node_action' => array(
      'type' => 'node',
      'label' => t('Rate a node in the Ting search context rating system'),
      'configurable' => TRUE,
      'vbo_configurable' => TRUE,
      'triggers' => array('any'),
    ),
  );
}

/**
 * Callback for our rate node action.
 */
function ting_search_context_rate_node_action(&$node, $context) {
  $search_context = ting_search_context_load($context['context']);
  $rating = $context['rating'];

  // Perform the rating
  ting_search_context_rate_node($search_context->context_id, $node->nid, $rating);

  $message = t('Rated %node in %context with a rating of %rating', array(
    '%node' => $node->title,
    '%context' => $search_context->name,
    '%rating' => $rating,
  ));
  drupal_set_message($message);
}

/**
 * Form builder for VBO per-bulk configuration form and Drupal core standard
 * advanced action form. Enables administrators to select the context and rating
 * for the nodes.
 */
function ting_search_context_rate_node_action_form($settings, &$form_state = NULL) {
  // Setup options arrays for the select-boxes
  $contexts = ting_search_context_get_all_contexts();
  $context_options = array();
  foreach ($contexts as $context) {
    $context_options[$context->context_id] = $context->name;
  }
  $rating_options = drupal_map_assoc(range(1, TING_SEARCH_CONTEXT_MAX_RATING));

  $form_context = array(
    '#type' => 'select',
    '#options' => $context_options,
    '#empty_option' => t('- Choose a context -'),
    '#default_value' => isset($settings['context']) ? $settings['context'] : '',
    '#required' => TRUE,
  );
  $form_rating = array(
    '#type' => 'select',
    '#options' => $rating_options,
    '#empty_option' => t('- Choose a rating -'),
    '#default_value' => isset($settings['rating']) ? $settings['rating'] : '',
    '#required' => TRUE,
  );

  $form = array();

  // This is VBO per-bulk configuration form since form_state parameter is
  // passed. In this case we provide a special more user friendly form with
  // the selected nodes displayed.
  if (isset($form_state) && !empty($form_state['selection'])) {
    $form['rating'] = $form_rating;
    $form['rating']['#prefix'] = '<h3>' . t('In what degree (rating):') . '</h3>';
    $selected_nodes = node_load_multiple($form_state['selection']);
    $items = array();
    foreach ($selected_nodes as $node) {
      $items[] = l(check_plain($node->title), 'node/' . $node->nid);
    }
    $form['selected_nodes'] = array(
      '#theme' => 'item_list',
      '#items' => $items,
      '#title' => t('Does the following content:'),
    );
    $form['context'] = $form_context;
    $form['context']['#prefix'] = '<h3 class="context-header">' . t('Relate to:') . '</h3>';
  }
  // Else it's an advanced action form and we just return a standard form with
  // 2 select-boxes.
  else {
    $form['context']['#title'] = t('Context');
    $form['rating']['#title'] = t('Rating');
    $form['context'] = $form_context;
    $form['rating'] = $form_rating;
  }

  return $form;
}

/**
 * Submit function for the rate node action form.
 */
function ting_search_context_rate_node_action_submit($form, &$form_state) {
  $return = array();
  $return['context'] = $form_state['values']['context'];
  $return['rating'] = $form_state['values']['rating'];
  return $return;
}

/**
 * Implements hook_views_bulk_operations_form_alter().
 */
function ting_search_context_views_bulk_operations_form_alter(&$form, &$form_state, $vbo) {
  // Always include our custom admin CSS.
  $path = drupal_get_path('module', 'ting_search_context');
  $form['#attached']['css'][] = $path . '/css/ting_search_context.admin.css';

  if ($form_state['step'] == 'views_bulk_operations_confirm_form') {
    $context = ting_search_context_load($form_state['values']['context']);
    $rating = $form_state['values']['rating'];

    // Since VBO isn't using render array for the confirm form, it's very
    // unpractically to override the text on it. Hence, we just unset the
    // description and add our own form-elements to the confirm form.
    unset($form['description']);

    $selected_nodes = node_load_multiple($form_state['selection']);
    $items = array();
    foreach ($selected_nodes as $node) {
      $items[] = l(check_plain($node->title), 'node/' . $node->nid);
    }
    $form['selected_nodes'] = array(
      '#theme' => 'item_list',
      '#items' => $items,
      '#title' => t('You selected the following content:')
    );
    $form['selected_context'] = array(
      '#theme' => 'html_tag',
      '#tag' => 'h3',
      '#value' => t('To be rated in the context: %context', array(
        '%context' => $context->name,
      )),
    );
    $form['selected_rating'] = array(
      '#theme' => 'html_tag',
      '#tag' => 'h3',
      '#value' => t('With a rating of: %rating', array(
        '%rating' => $rating,
      )),
    );
  }
}

/**
 * Searches the database for nodes rated in the context specified by
 * $context_id and randomly selects $count number of nodes to return. The
 * selection is based on the rating number of the ratings. For example, a node
 * with a rating of 5, is 5 times more likely to be selected compared to a node
 * with a rating of 1.
 * Note that nodes with a max rating of 10 will always be preferred over nodes
 * with lesser rating. This allows administrators to push very relevant content
 * to the users, giving them some control over the selection process. This has
 * one limitation: if there's more nodes with max rating than requested by
 * $count, the nodes to return will be selected randomly with even probability
 * between the max rated nodes.
 *
 *
 * @param int $context_id
 *   The ID of the context to search in.
 * @param int $count (optional)
 *   The max number of nodes to return. Defaults to 5.
 * @param mixed $node_types (optional)
 *   Can either be a string with a single node type, or an array of node types.
 *   Defaults to 'all' which returns nodes of all types.
 *
 * @return
 *   An array of node objects keyd by nid.
 */
function ting_search_context_get_nodes($context_id, $count = 5, $node_types = 'all') {
	$return = array();
	// No need to conteniue with the following input.
	if (empty($node_types) || $count < 1) {
		return $return;
	}

	// Setup a common query.
	$query = db_select('node', 'n');
	$nr_alias = $query->join(
		'ting_search_context_nodes_rated',
		'nr',
		'n.nid = %alias.nid'
	);
	$query->addField('n', 'nid', 'nid');
  $query->addField($nr_alias, 'rating', 'rating');
	$query->condition($nr_alias . '.context_id', $context_id)
		->condition('n.status', 1, '=')
		// Lets node access modules alter the query.
		// See: https://www.drupal.org/node/310077 and hook_query_TAG_alter().
		->addTag('node_access');

	// Add constraints on node types if specified.
	if ($node_types !== 'all') {
		$node_types = is_array($node_types) ? $node_types : array($node_types);
		$node_types_condition = db_or();
		foreach ($node_types as $node_type) {
			$node_types_condition->condition('n.type', $node_type);
		}
		$query->condition($node_types_condition);
	}

	// Fetch nodes with max rating.
	$query_max = clone $query;
	$query_max_result = $query_max->condition($nr_alias . '.rating', 10)
	  ->range(0, $count)
	  ->orderRandom()
	  ->execute();
	foreach ($query_max_result as $record) {
		$return[$record->nid] = node_load($record->nid);
	}
	$count -= $query_max->countQuery()->execute()->fetchField();

	// If there's room for more, look for nodes with less than max rating.
	if ($count > 0) {
		$query_less = clone $query;
		$query_less->condition($nr_alias. '.rating', 10, '<');
		// Only pick random if there's more nodes than we need.
		if ($query_less->countQuery()->execute()->fetchField() > $count) {
			$query_less_result = $query_less->execute();

			// Build array to randomly pick nodes from.
			$nodes = array();
			foreach ($query_less_result as $record) {
				$rating = $record->rating;
				for ($i = 0; $i < $rating; $i++) {
					$nodes[] = $record->nid;
				}
			}

			while ($count-- > 0) {
				$random_key = array_rand($nodes);
				$nid = $nodes[$random_key];
				$return[$nid] = node_load($nid);
				// Remove the node completely from the array.
				$nodes = array_diff_key($nodes, array_flip(array_keys($nodes, $nid)));
			}
		}
		// Else include all nodes.
		else  {
			foreach ($query_less_result as $record) {
				$return[$record->nid] = node_load($record->nid);
			}
		}
	}

	return $return;
}

/**
 * Implements hook_node_delete().
 *
 * When a node is deleted, ensure that any associated ratings is deleted from
 * the database.
 */
function ting_search_context_node_delete($node) {
  db_delete('ting_search_context_nodes_rated')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Saves a node rating in the database
 *
 * @param int $context_id
 *   The ID of the context to rate in.
 * @param int $nid
 *   The ID of node to rate.
 * @param int $rating
 *   The number of the rating (E.g. 1 - 10)
 *
 * @return undefined (https://www.drupal.org/node/310079)
 */
function ting_search_context_rate_node($context_id, $nid, $rating) {
	// Merge query ensures that nodes isn't rated in the same context twice.
	return db_merge('ting_search_context_nodes_rated')
		->key(array(
			'context_id' => $context_id,
			'nid' => $nid,
		))
		->fields(array(
			'rating' => $rating,
		))
		->execute();
}

/**
 * Saves a context in the database.
 *
 * @param string $type
 *   The machine-readable type of context.
 * @param string $name
 *   The human-readable name of the context.
 * @param string $context
 *   If $type is 'system' or 'subject' this should be the machine-readable name
 *   of the context.
 *   If $type is 'search' this should be the search string of the context.
 * @param string $subject
 *   The subject term for subject type contexts.
 *
 * @return string
 *   The context_id of the newly created context.
 *
 * @see ting_search_context_schema()
 */
function ting_search_context_save_context($type, $name, $context, $subject = NULL) {
	$fields = array(
		'type' => $type,
		'name' => $name,
	);

	switch ($type) {
		case 'subject':
			$fields += array('subject' => $subject);
			// Fall through
		case 'system':
			$fields += array('context' => $context);
			break;
		case 'search':
		  $fields += array('search' => $context);
		  break;
	}

	// TODO: Should we handle DB exceptions here or in the UI??
	return db_insert('ting_search_context_contexts')->fields($fields)->execute();
}

/**
 * Get the ID of the context (if any) with the specified parameters.
 *
 * @param string $type
 *   The type of the context to look for.
 * @param string $context
 *   For system and subject contexts this should be the machine-readable name
 *   of the context.
 *   For subject contexts this should be the search string.
 * @param $subject
 *   The subject term for subject type contexts
 *
 * @return mixed
 *   The context_id of the matching context.
 *   FALSE if no match.
 *
 * @see ting_search_context_schema()
 */
function ting_search_context_get_context_id($type, $context, $subject = NULL) {
	$query = db_select('ting_search_context_contexts', 'tsc')
		->fields('tsc', array('context_id'))
		->condition('tsc.type', $type);

	switch ($type) {
		case 'subject':
			$query->condition('tsc.subject', $subject);
			// Fall through
		case 'system':
			$query->condition('tsc.context', $context);
			break;
		case 'search':
			// $context will be a user entered search string, so we convert to upper
			// to make sure it compares.
			// NOTE: This will not be needed for collations suffixed with _ci.
			// See: https://dev.mysql.com/doc/refman/5.0/en/charset-mysql.html
      $query->where('UPPER(tsc.search) LIKE :context', array(
        ':context' => db_like(mb_strtoupper($context)),
      ));

      // Alternative method that looks for the search string within the context
      // search query:
			/*$query->where(":context LIKE CONCAT('%', UPPER(tsc.search), '%')", array(
				':context' => db_like(mb_strtoupper($context)),
			));*/
			break;
	}

	return $query->execute()->fetchField();
}

/**
 * Get all contexts in the system or all context of a specific type if the
 * $type parameter is supplied.
 *
 * @param string $type (optional)
 *   Constrain the returned contexts to a specific type.
 *
 * @return mixed
 *   Array representing the context.
 *   FALSE if no match.
 *
 * @see ting_search_context_schema()
 */
function ting_search_context_get_all_contexts($type = NULL) {
	$query = db_select('ting_search_context_contexts', 'tsc')
		->fields('tsc');

  if (isset($type)) {
    $query->condition('tsc', $type);
  }

	return $query->execute()->fetchAll();
}
